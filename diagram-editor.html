<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mermaid + BPMN 2.0 Editor | Simon Vegelahn</title>
    <script src="https://cdn.jsdelivr.net/npm/bpmn-js@17.2.0/dist/bpmn-navigated-viewer.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dagre@0.8.5/dist/dagre.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --bg-input: #0d1117;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --text-muted: #484f58;
            --border: #30363d;
            --accent: #58a6ff;
            --accent-hover: #79c0ff;
            --success: #3fb950;
            --warning: #d29922;
            --error: #f85149;
            --shadow: 0 8px 24px rgba(0,0,0,0.4);
        }

        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f6f8fa;
            --bg-tertiary: #eaeef2;
            --bg-input: #ffffff;
            --text-primary: #1f2328;
            --text-secondary: #656d76;
            --text-muted: #8c959f;
            --border: #d0d7de;
            --accent: #0969da;
            --accent-hover: #0550ae;
            --shadow: 0 8px 24px rgba(0,0,0,0.1);
        }

        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; overflow: hidden; }

        body {
            font-family: 'IBM Plex Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
        }

        /* Layout */
        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Header */
        .header {
            height: 52px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            flex-shrink: 0;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            font-size: 14px;
            color: var(--text-primary);
        }

        .logo-mark {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, var(--accent), #a371f7);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .logo-mark svg { width: 16px; height: 16px; color: white; }

        .version-badge {
            font-size: 10px;
            font-weight: 500;
            padding: 2px 6px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text-secondary);
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            font-size: 13px;
            font-weight: 500;
            font-family: inherit;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn:hover {
            background: var(--border);
            color: var(--text-primary);
        }

        .btn svg { width: 16px; height: 16px; }

        .btn-primary {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
            border-color: var(--accent-hover);
        }

        .btn-icon {
            width: 32px;
            height: 32px;
            padding: 0;
            justify-content: center;
        }

        /* Dropdown */
        .dropdown {
            position: relative;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            min-width: 200px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: var(--shadow);
            z-index: 1000;
            display: none;
        }

        .dropdown-menu.open { display: block; }

        .dropdown-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            font-size: 13px;
            color: var(--text-secondary);
            cursor: pointer;
            border-bottom: 1px solid var(--border);
        }

        .dropdown-item:last-child { border-bottom: none; }
        .dropdown-item:hover { background: var(--bg-tertiary); color: var(--text-primary); }
        .dropdown-item svg { width: 16px; height: 16px; opacity: 0.7; }

        /* Main Content */
        .main {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Editor Panel */
        .editor-panel {
            width: 50%;
            min-width: 400px;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border);
            background: var(--bg-secondary);
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border);
            background: var(--bg-tertiary);
        }

        .panel-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
        }

        .panel-actions {
            display: flex;
            gap: 4px;
        }

        .panel-action {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: 4px;
        }

        .panel-action:hover { background: var(--border); color: var(--text-primary); }
        .panel-action svg { width: 14px; height: 14px; }

        .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .code-editor {
            flex: 1;
            padding: 12px;
            background: var(--bg-input);
            border: none;
            resize: none;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 13px;
            line-height: 1.6;
            color: var(--text-primary);
            outline: none;
            overflow: auto;
        }

        .code-editor::placeholder { color: var(--text-muted); }

        /* Reference Panel */
        .reference-panel {
            border-top: 1px solid var(--border);
            background: var(--bg-tertiary);
            max-height: 45%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .reference-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .reference-tabs {
            display: flex;
            gap: 2px;
        }

        .reference-tab {
            padding: 4px 10px;
            font-size: 11px;
            font-weight: 500;
            border: none;
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: 4px;
            font-family: inherit;
        }

        .reference-tab:hover { color: var(--text-secondary); }
        .reference-tab.active { background: var(--accent); color: white; }

        .reference-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .ref-section {
            margin-bottom: 16px;
        }

        .ref-section:last-child { margin-bottom: 0; }

        .ref-section-title {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            margin-bottom: 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid var(--border);
        }

        .ref-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 4px;
        }

        .ref-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.1s;
        }

        .ref-item:hover { background: var(--bg-secondary); }
        .ref-item:active { transform: scale(0.98); }

        .ref-item code {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            padding: 2px 6px;
            background: var(--bg-input);
            border-radius: 3px;
            color: var(--accent);
            white-space: nowrap;
        }

        .ref-item:hover code { background: var(--accent); color: white; }

        .ref-item span {
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* Preview Panel */
        .preview-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
        }

        .preview-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border);
            background: var(--bg-secondary);
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .zoom-btn {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
        }

        .zoom-btn:hover { background: var(--border); color: var(--text-primary); }

        .zoom-level {
            font-size: 12px;
            color: var(--text-muted);
            min-width: 50px;
            text-align: center;
            font-family: 'IBM Plex Mono', monospace;
        }

        /* Navigation Controls */
        .nav-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            z-index: 100;
        }

        .nav-row {
            display: flex;
            gap: 2px;
        }

        .nav-btn {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border);
            background: var(--bg-secondary);
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 6px;
            font-size: 16px;
            transition: all 0.15s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .nav-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-color: var(--accent);
        }

        .nav-btn:active {
            transform: scale(0.95);
            background: var(--accent);
            color: white;
        }

        .nav-btn svg {
            width: 18px;
            height: 18px;
        }

        .nav-center {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border);
            background: var(--bg-tertiary);
            color: var(--text-muted);
            border-radius: 6px;
            font-size: 10px;
            cursor: pointer;
        }

        .nav-center:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .preview-container {
            flex: 1;
            overflow: auto;
            background: white;
            position: relative;
        }

        #bpmn-canvas {
            width: 100%;
            height: 100%;
            min-height: 500px;
            cursor: grab;
        }
        
        #bpmn-canvas:active {
            cursor: grabbing;
        }

        .preview-error {
            margin: 24px;
            padding: 16px;
            background: rgba(248, 81, 73, 0.1);
            border: 1px solid rgba(248, 81, 73, 0.3);
            border-radius: 8px;
            color: var(--error);
        }

        .preview-error-title {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .preview-error-message {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            opacity: 0.9;
        }

        /* Resize Handle */
        .resize-handle {
            width: 4px;
            background: var(--border);
            cursor: col-resize;
            transition: background 0.15s;
            flex-shrink: 0;
        }

        .resize-handle:hover { background: var(--accent); }

        /* Status Bar */
        .status-bar {
            height: 24px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 12px;
            font-size: 11px;
            color: var(--text-muted);
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
        }

        .status-dot.error { background: var(--error); }

        /* Theme toggle icons */
        .theme-toggle .icon-moon { display: none; }
        [data-theme="light"] .theme-toggle .icon-sun { display: none; }
        [data-theme="light"] .theme-toggle .icon-moon { display: block; }

        /* Toast notifications */
        .toast {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            padding: 10px 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: var(--shadow);
            font-size: 13px;
            color: var(--text-primary);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 10000;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

        /* File input */
        .file-input { display: none; }
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <div class="header-left">
                <div class="logo">
                    <div class="logo-mark">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                            <rect x="3" y="3" width="18" height="18" rx="2"/>
                            <path d="M9 9h6v6H9z"/>
                        </svg>
                    </div>
                    <span>BPMN 2.0 Editor</span>
                </div>
                <span class="version-badge">Full Spec</span>
            </div>

            <div class="header-actions">
                <div class="dropdown">
                    <button class="btn" onclick="toggleDropdown('examplesMenu')">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
                            <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
                        </svg>
                        Examples
                    </button>
                    <div class="dropdown-menu" id="examplesMenu">
                        <div class="dropdown-item" onclick="loadExample('simple')">Simple Process</div>
                        <div class="dropdown-item" onclick="loadExample('gateways')">All Gateways</div>
                        <div class="dropdown-item" onclick="loadExample('events')">Event Types</div>
                        <div class="dropdown-item" onclick="loadExample('tasks')">Task Types</div>
                        <div class="dropdown-item" onclick="loadExample('pools')">Pools & Lanes</div>
                        <div class="dropdown-item" onclick="loadExample('complete')">Complete Demo</div>
                    </div>
                </div>

                <label class="btn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="17 8 12 3 7 8"/>
                        <line x1="12" y1="3" x2="12" y2="15"/>
                    </svg>
                    Import
                    <input type="file" class="file-input" id="fileInput" accept=".bpmn,.xml,.txt" onchange="importFile(event)">
                </label>

                <div class="dropdown">
                    <button class="btn btn-primary" onclick="toggleDropdown('exportMenu')">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                            <polyline points="7 10 12 15 17 10"/>
                            <line x1="12" y1="15" x2="12" y2="3"/>
                        </svg>
                        Export
                    </button>
                    <div class="dropdown-menu" id="exportMenu">
                        <div class="dropdown-item" onclick="exportBPMN()">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                <polyline points="14 2 14 8 20 8"/>
                            </svg>
                            BPMN 2.0 XML (Signavio)
                        </div>
                        <div class="dropdown-item" onclick="exportSVG()">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2"/>
                                <circle cx="8.5" cy="8.5" r="1.5"/>
                                <polyline points="21 15 16 10 5 21"/>
                            </svg>
                            SVG Image
                        </div>
                    </div>
                </div>

                <button class="btn btn-icon theme-toggle" onclick="toggleTheme()">
                    <svg class="icon-sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="5"/>
                        <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
                    </svg>
                    <svg class="icon-moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                    </svg>
                </button>
            </div>
        </header>

        <main class="main">
            <div class="editor-panel" id="editorPanel">
                <div class="panel-header">
                    <span class="panel-title">DSL Editor</span>
                    <div class="panel-actions">
                        <button class="panel-action" onclick="copyCode()" title="Copy">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="9" y="9" width="13" height="13" rx="2"/>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                            </svg>
                        </button>
                        <button class="panel-action" onclick="clearEditor()" title="Clear">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="3 6 5 6 21 6"/>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <div class="editor-container">
                    <textarea class="code-editor" id="codeEditor" placeholder="Enter BPMN DSL code here..." spellcheck="false"></textarea>
                </div>

                <div class="reference-panel" id="referencePanel">
                    <div class="reference-header">
                        <span class="panel-title">Syntax Reference</span>
                        <div class="reference-tabs">
                            <button class="reference-tab active" onclick="setRefTab('events')">Events</button>
                            <button class="reference-tab" onclick="setRefTab('activities')">Activities</button>
                            <button class="reference-tab" onclick="setRefTab('gateways')">Gateways</button>
                            <button class="reference-tab" onclick="setRefTab('data')">Data</button>
                            <button class="reference-tab" onclick="setRefTab('pools')">Pools</button>
                        </div>
                    </div>
                    <div class="reference-content" id="referenceContent">
                        <!-- Content injected by JS -->
                    </div>
                </div>
            </div>

            <div class="resize-handle" id="resizeHandle"></div>

            <div class="preview-panel">
                <div class="preview-toolbar">
                    <span class="panel-title">Preview</span>
                    <div class="zoom-controls">
                        <button class="zoom-btn" onclick="zoomOut()">−</button>
                        <span class="zoom-level" id="zoomLevel">100%</span>
                        <button class="zoom-btn" onclick="zoomIn()">+</button>
                        <button class="zoom-btn" onclick="fitView()" title="Fit to view">⊡</button>
                    </div>
                </div>
                <div class="preview-container">
                    <div id="bpmn-canvas"></div>
                    
                    <!-- Navigation Controls -->
                    <div class="nav-controls">
                        <div class="nav-row">
                            <button class="nav-btn" onclick="panCanvas(0, -80)" title="Pan Up">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M12 19V5M5 12l7-7 7 7"/>
                                </svg>
                            </button>
                        </div>
                        <div class="nav-row">
                            <button class="nav-btn" onclick="panCanvas(-80, 0)" title="Pan Left">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M19 12H5M12 5l-7 7 7 7"/>
                                </svg>
                            </button>
                            <button class="nav-center" onclick="resetView()" title="Reset View">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="3"/>
                                    <path d="M12 2v2M12 20v2M2 12h2M20 12h2"/>
                                </svg>
                            </button>
                            <button class="nav-btn" onclick="panCanvas(80, 0)" title="Pan Right">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M5 12h14M12 5l7 7-7 7"/>
                                </svg>
                            </button>
                        </div>
                        <div class="nav-row">
                            <button class="nav-btn" onclick="panCanvas(0, 80)" title="Pan Down">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M12 5v14M5 12l7 7 7-7"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <div class="status-bar">
            <div class="status-item">
                <span class="status-dot" id="statusDot"></span>
                <span id="statusText">Ready</span>
            </div>
            <div class="status-item">
                <span id="elementCount">0 elements</span>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        // ============================================================
        // STATE
        // ============================================================
        let bpmnViewer = null;
        let lastBpmnXml = null;
        let debounceTimer = null;
        let zoomLevel = 1;
        let currentRefTab = 'events';

        // ============================================================
        // BPMN 2.0 COMPLETE ELEMENT DEFINITIONS
        // ============================================================
        
        // All Start Event Types
        const START_EVENTS = {
            '(start)': { type: 'startEvent', trigger: null, label: 'None Start' },
            '(start:message)': { type: 'startEvent', trigger: 'messageEventDefinition', label: 'Message Start' },
            '(start:timer)': { type: 'startEvent', trigger: 'timerEventDefinition', label: 'Timer Start' },
            '(start:conditional)': { type: 'startEvent', trigger: 'conditionalEventDefinition', label: 'Conditional Start' },
            '(start:signal)': { type: 'startEvent', trigger: 'signalEventDefinition', label: 'Signal Start' },
            '(start:multiple)': { type: 'startEvent', trigger: 'multipleEventDefinition', label: 'Multiple Start' },
            '(start:parallel)': { type: 'startEvent', trigger: 'parallelMultipleEventDefinition', label: 'Parallel Multiple Start' },
            '(start:error)': { type: 'startEvent', trigger: 'errorEventDefinition', label: 'Error Start (Event Sub)' },
            '(start:escalation)': { type: 'startEvent', trigger: 'escalationEventDefinition', label: 'Escalation Start (Event Sub)' },
            '(start:compensation)': { type: 'startEvent', trigger: 'compensateEventDefinition', label: 'Compensation Start (Event Sub)' },
        };

        // All Intermediate Catch Events
        const CATCH_EVENTS = {
            '(catch:message)': { type: 'intermediateCatchEvent', trigger: 'messageEventDefinition', label: 'Message Catch' },
            '(catch:timer)': { type: 'intermediateCatchEvent', trigger: 'timerEventDefinition', label: 'Timer Catch' },
            '(timer)': { type: 'intermediateCatchEvent', trigger: 'timerEventDefinition', label: 'Timer (shorthand)' },
            '(catch:conditional)': { type: 'intermediateCatchEvent', trigger: 'conditionalEventDefinition', label: 'Conditional Catch' },
            '(catch:signal)': { type: 'intermediateCatchEvent', trigger: 'signalEventDefinition', label: 'Signal Catch' },
            '(catch:link)': { type: 'intermediateCatchEvent', trigger: 'linkEventDefinition', label: 'Link Catch' },
            '(catch:multiple)': { type: 'intermediateCatchEvent', trigger: 'multipleEventDefinition', label: 'Multiple Catch' },
            '(catch:parallel)': { type: 'intermediateCatchEvent', trigger: 'parallelMultipleEventDefinition', label: 'Parallel Multiple Catch' },
        };

        // All Intermediate Throw Events
        const THROW_EVENTS = {
            '(throw)': { type: 'intermediateThrowEvent', trigger: null, label: 'None Throw' },
            '(throw:message)': { type: 'intermediateThrowEvent', trigger: 'messageEventDefinition', label: 'Message Throw' },
            '(throw:signal)': { type: 'intermediateThrowEvent', trigger: 'signalEventDefinition', label: 'Signal Throw' },
            '(throw:escalation)': { type: 'intermediateThrowEvent', trigger: 'escalationEventDefinition', label: 'Escalation Throw' },
            '(throw:compensation)': { type: 'intermediateThrowEvent', trigger: 'compensateEventDefinition', label: 'Compensation Throw' },
            '(throw:link)': { type: 'intermediateThrowEvent', trigger: 'linkEventDefinition', label: 'Link Throw' },
            '(throw:multiple)': { type: 'intermediateThrowEvent', trigger: 'multipleEventDefinition', label: 'Multiple Throw' },
        };

        // All End Event Types
        const END_EVENTS = {
            '(end)': { type: 'endEvent', trigger: null, label: 'None End' },
            '(end:message)': { type: 'endEvent', trigger: 'messageEventDefinition', label: 'Message End' },
            '(end:signal)': { type: 'endEvent', trigger: 'signalEventDefinition', label: 'Signal End' },
            '(end:error)': { type: 'endEvent', trigger: 'errorEventDefinition', label: 'Error End' },
            '(error)': { type: 'endEvent', trigger: 'errorEventDefinition', label: 'Error (shorthand)' },
            '(end:escalation)': { type: 'endEvent', trigger: 'escalationEventDefinition', label: 'Escalation End' },
            '(end:cancel)': { type: 'endEvent', trigger: 'cancelEventDefinition', label: 'Cancel End' },
            '(end:compensation)': { type: 'endEvent', trigger: 'compensateEventDefinition', label: 'Compensation End' },
            '(end:terminate)': { type: 'endEvent', trigger: 'terminateEventDefinition', label: 'Terminate End' },
            '(terminate)': { type: 'endEvent', trigger: 'terminateEventDefinition', label: 'Terminate (shorthand)' },
            '(end:multiple)': { type: 'endEvent', trigger: 'multipleEventDefinition', label: 'Multiple End' },
        };

        // Boundary Events (attached to tasks)
        const BOUNDARY_TRIGGERS = {
            'message': 'messageEventDefinition',
            'timer': 'timerEventDefinition',
            'conditional': 'conditionalEventDefinition',
            'signal': 'signalEventDefinition',
            'error': 'errorEventDefinition',
            'escalation': 'escalationEventDefinition',
            'cancel': 'cancelEventDefinition',
            'compensation': 'compensateEventDefinition',
            'multiple': 'multipleEventDefinition',
            'parallel': 'parallelMultipleEventDefinition',
        };

        // All Task Types
        const TASK_TYPES = {
            '': { type: 'task', label: 'Abstract Task' },
            'task:': { type: 'task', label: 'Task' },
            'user:': { type: 'userTask', label: 'User Task' },
            'service:': { type: 'serviceTask', label: 'Service Task' },
            'script:': { type: 'scriptTask', label: 'Script Task' },
            'rule:': { type: 'businessRuleTask', label: 'Business Rule Task' },
            'send:': { type: 'sendTask', label: 'Send Task' },
            'receive:': { type: 'receiveTask', label: 'Receive Task' },
            'manual:': { type: 'manualTask', label: 'Manual Task' },
        };

        // Sub-Process Types
        const SUBPROCESS_TYPES = {
            'sub:': { type: 'subProcess', label: 'Sub-Process' },
            'event-sub:': { type: 'subProcess', triggeredByEvent: true, label: 'Event Sub-Process' },
            'transaction:': { type: 'transaction', label: 'Transaction' },
            'adhoc:': { type: 'adHocSubProcess', label: 'Ad-Hoc Sub-Process' },
            'call:': { type: 'callActivity', label: 'Call Activity' },
        };

        // Task Markers
        const TASK_MARKERS = {
            '~loop': { loopCharacteristics: 'standardLoopCharacteristics', label: 'Loop' },
            '~parallel': { loopCharacteristics: 'multiInstanceLoopCharacteristics', isSequential: false, label: 'Parallel MI' },
            '~sequential': { loopCharacteristics: 'multiInstanceLoopCharacteristics', isSequential: true, label: 'Sequential MI' },
            '~compensation': { isForCompensation: true, label: 'Compensation' },
        };

        // All Gateway Types
        const GATEWAY_TYPES = {
            '<': { type: 'exclusiveGateway', label: 'Exclusive (XOR)' },
            '<x': { type: 'exclusiveGateway', label: 'Exclusive (XOR)' },
            '<+': { type: 'parallelGateway', label: 'Parallel (AND)' },
            '<o': { type: 'inclusiveGateway', label: 'Inclusive (OR)' },
            '<*': { type: 'complexGateway', label: 'Complex' },
            '<@': { type: 'eventBasedGateway', label: 'Event-Based' },
            '<@+': { type: 'eventBasedGateway', instantiate: true, label: 'Event-Based (Instantiating)' },
            '<@x': { type: 'eventBasedGateway', exclusive: true, label: 'Exclusive Event-Based' },
        };

        // Data Elements
        const DATA_TYPES = {
            '{data:': { type: 'dataObjectReference', label: 'Data Object' },
            '{input:': { type: 'dataInput', label: 'Data Input' },
            '{output:': { type: 'dataOutput', label: 'Data Output' },
            '{store:': { type: 'dataStoreReference', label: 'Data Store' },
            '{collection:': { type: 'dataObjectReference', isCollection: true, label: 'Data Collection' },
        };

        // Merge all events for parsing
        const ALL_EVENTS = { ...START_EVENTS, ...CATCH_EVENTS, ...THROW_EVENTS, ...END_EVENTS };

        // ============================================================
        // REFERENCE PANEL DATA
        // ============================================================
        const REFERENCE_DATA = {
            events: {
                'Start Events': [
                    { code: '(start)', desc: 'None Start' },
                    { code: '(start:message)', desc: 'Message Start' },
                    { code: '(start:timer)', desc: 'Timer Start' },
                    { code: '(start:signal)', desc: 'Signal Start' },
                    { code: '(start:conditional)', desc: 'Conditional Start' },
                    { code: '(start:error)', desc: 'Error Start' },
                    { code: '(start:escalation)', desc: 'Escalation Start' },
                    { code: '(start:compensation)', desc: 'Compensation Start' },
                    { code: '(start:multiple)', desc: 'Multiple Start' },
                    { code: '(start:parallel)', desc: 'Parallel Multiple' },
                ],
                'Intermediate Catch': [
                    { code: '(timer)', desc: 'Timer (shorthand)' },
                    { code: '(catch:message)', desc: 'Message Catch' },
                    { code: '(catch:timer)', desc: 'Timer Catch' },
                    { code: '(catch:signal)', desc: 'Signal Catch' },
                    { code: '(catch:conditional)', desc: 'Conditional Catch' },
                    { code: '(catch:link)', desc: 'Link Catch' },
                    { code: '(catch:multiple)', desc: 'Multiple Catch' },
                    { code: '(catch:parallel)', desc: 'Parallel Multiple' },
                ],
                'Intermediate Throw': [
                    { code: '(throw)', desc: 'None Throw' },
                    { code: '(throw:message)', desc: 'Message Throw' },
                    { code: '(throw:signal)', desc: 'Signal Throw' },
                    { code: '(throw:escalation)', desc: 'Escalation Throw' },
                    { code: '(throw:compensation)', desc: 'Compensation Throw' },
                    { code: '(throw:link)', desc: 'Link Throw' },
                ],
                'End Events': [
                    { code: '(end)', desc: 'None End' },
                    { code: '(error)', desc: 'Error End' },
                    { code: '(terminate)', desc: 'Terminate End' },
                    { code: '(end:message)', desc: 'Message End' },
                    { code: '(end:signal)', desc: 'Signal End' },
                    { code: '(end:escalation)', desc: 'Escalation End' },
                    { code: '(end:cancel)', desc: 'Cancel End' },
                    { code: '(end:compensation)', desc: 'Compensation End' },
                ],
                'Boundary Events': [
                    { code: '(boundary:timer @TaskId)', desc: 'Timer Boundary' },
                    { code: '(boundary:message @TaskId)', desc: 'Message Boundary' },
                    { code: '(boundary:error @TaskId)', desc: 'Error Boundary' },
                    { code: '(boundary:signal @TaskId)', desc: 'Signal Boundary' },
                    { code: '(boundary:escalation @TaskId)', desc: 'Escalation Boundary' },
                    { code: '(boundary!:timer @TaskId)', desc: 'Non-interrupting Timer' },
                ],
            },
            activities: {
                'Task Types': [
                    { code: '[Task Name]', desc: 'Abstract Task' },
                    { code: '[user: Name]', desc: 'User Task' },
                    { code: '[service: Name]', desc: 'Service Task' },
                    { code: '[script: Name]', desc: 'Script Task' },
                    { code: '[rule: Name]', desc: 'Business Rule Task' },
                    { code: '[send: Name]', desc: 'Send Task' },
                    { code: '[receive: Name]', desc: 'Receive Task' },
                    { code: '[manual: Name]', desc: 'Manual Task' },
                ],
                'Sub-Processes': [
                    { code: '[[sub: Name]]', desc: 'Collapsed Sub-Process' },
                    { code: '[[event-sub: Name]]', desc: 'Event Sub-Process' },
                    { code: '[[transaction: Name]]', desc: 'Transaction' },
                    { code: '[[adhoc: Name]]', desc: 'Ad-Hoc Sub-Process' },
                    { code: '[call: Name]', desc: 'Call Activity' },
                ],
                'Task Markers': [
                    { code: '[user: Name ~loop]', desc: 'With Loop' },
                    { code: '[service: Name ~parallel]', desc: 'Parallel Multi-Instance' },
                    { code: '[task: Name ~sequential]', desc: 'Sequential Multi-Instance' },
                    { code: '[task: Name ~compensation]', desc: 'Compensation Activity' },
                ],
            },
            gateways: {
                'Gateway Types': [
                    { code: '<Decision?>', desc: 'Exclusive (XOR)' },
                    { code: '<x Decision?>', desc: 'Exclusive (explicit)' },
                    { code: '<+ Split>', desc: 'Parallel (AND)' },
                    { code: '<o Choice>', desc: 'Inclusive (OR)' },
                    { code: '<* Complex>', desc: 'Complex Gateway' },
                    { code: '<@ EventGW>', desc: 'Event-Based Gateway' },
                    { code: '<@+ Instantiate>', desc: 'Event-Based (Instantiating)' },
                ],
                'Connections': [
                    { code: '->', desc: 'Sequence Flow' },
                    { code: '|Yes| ->', desc: 'Conditional Flow' },
                    { code: '|default| ->', desc: 'Default Flow' },
                    { code: '~~>', desc: 'Message Flow' },
                    { code: '-->', desc: 'Association' },
                ],
            },
            data: {
                'Data Objects': [
                    { code: '{data: Name}', desc: 'Data Object' },
                    { code: '{input: Name}', desc: 'Data Input' },
                    { code: '{output: Name}', desc: 'Data Output' },
                    { code: '{store: Name}', desc: 'Data Store' },
                    { code: '{collection: Name}', desc: 'Data Collection' },
                ],
                'Artifacts': [
                    { code: '// Comment text', desc: 'Text Annotation' },
                    { code: '(( Group Name ))', desc: 'Group' },
                ],
            },
            pools: {
                'Pools & Lanes': [
                    { code: 'pool "Name" { ... }', desc: 'Pool (Participant)' },
                    { code: 'lane "Name" { ... }', desc: 'Lane' },
                    { code: 'pool "Name" collapsed', desc: 'Collapsed Pool (Black Box)' },
                ],
                'Message Flows': [
                    { code: 'Pool1.Task ~~> Pool2.Task', desc: 'Cross-pool Message' },
                ],
            },
        };

        // ============================================================
        // EXAMPLES
        // ============================================================
        const EXAMPLES = {
            simple: `// Simple Order Process
(start) -> [Receive Order] -> <In Stock?>
<In Stock?> -> |Yes| [Pack Items] -> [Ship Order] -> (end)
<In Stock?> -> |No| [Reorder Stock] -> (timer) -> [Pack Items]`,

            gateways: `// Gateway Types Demo
(start) -> <Exclusive?>
<Exclusive?> -> |Path A| [Task A] -> <+ Parallel Split>
<Exclusive?> -> |Path B| [Task B] -> <+ Parallel Split>
<+ Parallel Split> -> [Parallel 1]
<+ Parallel Split> -> [Parallel 2]
[Parallel 1] -> <+ Parallel Join>
[Parallel 2] -> <+ Parallel Join>
<+ Parallel Join> -> <o Inclusive?>
<o Inclusive?> -> |Option 1| [Option Task 1] -> <o Inclusive Join>
<o Inclusive?> -> |Option 2| [Option Task 2] -> <o Inclusive Join>
<o Inclusive Join> -> <@ Event Gateway>
<@ Event Gateway> -> (catch:message) -> [Handle Message] -> (end)
<@ Event Gateway> -> (timer) -> [Handle Timeout] -> (end)`,

            events: `// Event Types Demo
(start:message) -> [user: Process Request]
[user: Process Request] -> (timer) -> [Check Status]
[Check Status] -> <Result?>
<Result?> -> |Success| (throw:signal) -> [Notify Success] -> (end)
<Result?> -> |Warning| (throw:escalation) -> [Handle Escalation] -> (end:escalation)
<Result?> -> |Failure| [Log Error] -> (error)`,

            tasks: `// Task Types Demo
(start) -> [user: Review Request]
[user: Review Request] -> [service: Validate Data]
[service: Validate Data] -> [script: Transform]
[script: Transform] -> [rule: Apply Rules]
[rule: Apply Rules] -> [send: Send Notification]
[send: Send Notification] -> [receive: Wait Response]
[receive: Wait Response] -> [manual: Physical Check]
[manual: Physical Check] -> (end)`,

            pools: `// Multi-Pool Process
pool "Customer" {
  (start) -> [Submit Order] -> [Wait for Confirmation] -> (end)
}

pool "Sales" {
  (start:message) -> [user: Process Order] -> <Approved?>
  <Approved?> -> |Yes| [send: Confirm Order] -> (end)
  <Approved?> -> |No| [send: Reject Order] -> (end)
}`,

            complete: `// Complete BPMN 2.0 Demo
(start:message) -> [user: Receive Request]
[user: Receive Request] -> <+ Parallel>
<+ Parallel> -> [service: Validate ~parallel] -> <Valid?>
<+ Parallel> -> [script: Log Request]
<Valid?> -> |Yes| [rule: Apply Policy] -> <o Options>
<Valid?> -> |No| (throw:escalation) -> [Handle Error] -> (error)
<o Options> -> |Full| [send: Full Notification] -> <o Merge>
<o Options> -> |Partial| [send: Partial Notification] -> <o Merge>
<o Merge> -> <+ Join>
[script: Log Request] -> <+ Join>
<+ Join> -> [receive: Wait Confirmation]
[receive: Wait Confirmation] -> [manual: Final Review]
[manual: Final Review] -> <@ Event Decision>
<@ Event Decision> -> (catch:message) -> [Process Response] -> (end)
<@ Event Decision> -> (timer) -> [Handle Timeout] -> (terminate)`,
        };

        // ============================================================
        // INITIALIZATION
        // ============================================================
        document.addEventListener('DOMContentLoaded', () => {
            initTheme();
            initResizer();
            initViewer();
            renderReference();
            
            document.getElementById('codeEditor').value = EXAMPLES.simple;
            render();

            document.getElementById('codeEditor').addEventListener('input', () => {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(render, 400);
            });

            // Close dropdowns on outside click
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.dropdown')) {
                    document.querySelectorAll('.dropdown-menu').forEach(m => m.classList.remove('open'));
                }
            });
        });

        function initViewer() {
            bpmnViewer = new BpmnJS({
                container: '#bpmn-canvas'
            });
            
            // Update zoom display when user scrolls to zoom
            const container = document.getElementById('bpmn-canvas');
            container.addEventListener('wheel', () => {
                // Debounce the zoom display update
                setTimeout(updateZoomDisplay, 50);
            });
        }

        // ============================================================
        // THEME
        // ============================================================
        function initTheme() {
            const saved = localStorage.getItem('bpmn-theme');
            if (saved === 'light') {
                document.documentElement.setAttribute('data-theme', 'light');
            }
        }

        function toggleTheme() {
            const isLight = document.documentElement.getAttribute('data-theme') === 'light';
            document.documentElement.setAttribute('data-theme', isLight ? 'dark' : 'light');
            localStorage.setItem('bpmn-theme', isLight ? 'dark' : 'light');
        }

        // ============================================================
        // REFERENCE PANEL
        // ============================================================
        function renderReference() {
            const content = document.getElementById('referenceContent');
            const data = REFERENCE_DATA[currentRefTab];
            
            let html = '';
            for (const [section, items] of Object.entries(data)) {
                html += `<div class="ref-section">
                    <div class="ref-section-title">${section}</div>
                    <div class="ref-grid">
                        ${items.map(item => `
                            <div class="ref-item" onclick="insertCode('${escapeHtml(item.code)}')">
                                <code>${escapeHtml(item.code)}</code>
                                <span>${item.desc}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>`;
            }
            content.innerHTML = html;
        }

        function setRefTab(tab) {
            currentRefTab = tab;
            document.querySelectorAll('.reference-tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            renderReference();
        }

        function insertCode(code) {
            const editor = document.getElementById('codeEditor');
            const start = editor.selectionStart;
            const end = editor.selectionEnd;
            const value = editor.value;
            
            editor.value = value.substring(0, start) + code + value.substring(end);
            editor.selectionStart = editor.selectionEnd = start + code.length;
            editor.focus();
            
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(render, 400);
            
            showToast('Inserted: ' + code);
        }

        // ============================================================
        // DSL PARSER
        // ============================================================
        function parseDSL(code) {
            const elements = new Map();
            const flows = [];
            const pools = [];
            const lanes = [];
            const boundaryEvents = [];
            let elementId = 0;
            
            // Normalize connectors
            let normalized = code
                .replace(/~~>/g, '->')
                .replace(/-->/g, '->');
            
            // Split into lines, filter empty and pure comments
            const lines = normalized.split('\n')
                .map(l => l.trim())
                .filter(l => l && !l.startsWith('//'));

            // Parse each line
            lines.forEach(line => {
                // Skip pool/lane definitions for now (simplified)
                if (line.startsWith('pool ') || line.startsWith('lane ') || line === '{' || line === '}') {
                    return;
                }

                // Split by connector
                const parts = line.split('->').map(p => p.trim()).filter(p => p);
                
                for (let i = 0; i < parts.length; i++) {
                    let part = parts[i];
                    let condition = null;
                    
                    // Extract condition label |Yes|
                    const condMatch = part.match(/^\|([^|]+)\|\s*(.+)$/);
                    if (condMatch) {
                        condition = condMatch[1];
                        part = condMatch[2];
                    }
                    
                    // Parse element
                    if (!elements.has(part)) {
                        elementId++;
                        const parsed = parseElement(part, elementId);
                        elements.set(part, parsed);
                    }
                    
                    // Create flow
                    if (i > 0) {
                        let sourcePart = parts[i - 1];
                        const srcCond = sourcePart.match(/^\|([^|]+)\|\s*(.+)$/);
                        if (srcCond) sourcePart = srcCond[2];
                        
                        const source = elements.get(sourcePart);
                        const target = elements.get(part);
                        
                        if (source && target) {
                            flows.push({
                                id: `Flow_${flows.length + 1}`,
                                sourceRef: source.id,
                                targetRef: target.id,
                                sourceKey: sourcePart,
                                targetKey: part,
                                name: condition || '',
                                isDefault: condition === 'default'
                            });
                        }
                    }
                }
            });

            return { elements, flows, pools, lanes, boundaryEvents };
        }

        function parseElement(part, id) {
            const elementId = `Element_${id}`;
            
            // Check events
            const lowerPart = part.toLowerCase();
            for (const [pattern, config] of Object.entries(ALL_EVENTS)) {
                if (lowerPart === pattern) {
                    return {
                        id: elementId,
                        key: part,
                        type: config.type,
                        trigger: config.trigger,
                        name: '',
                        width: 36,
                        height: 36
                    };
                }
            }

            // Check gateways
            if (part.startsWith('<') && part.endsWith('>')) {
                const content = part.slice(1, -1);
                let gwType = 'exclusiveGateway';
                let name = content;
                
                // Check gateway prefixes
                for (const [prefix, config] of Object.entries(GATEWAY_TYPES)) {
                    const checkPrefix = prefix.slice(1); // Remove <
                    if (content.startsWith(checkPrefix) && checkPrefix !== '') {
                        gwType = config.type;
                        name = content.slice(checkPrefix.length).trim();
                        break;
                    }
                }
                
                return {
                    id: elementId,
                    key: part,
                    type: gwType,
                    name: name,
                    width: 50,
                    height: 50
                };
            }

            // Check sub-processes [[...]]
            if (part.startsWith('[[') && part.endsWith(']]')) {
                const content = part.slice(2, -2).trim();
                let subType = 'subProcess';
                let name = content;
                
                for (const [prefix, config] of Object.entries(SUBPROCESS_TYPES)) {
                    if (content.toLowerCase().startsWith(prefix)) {
                        subType = config.type;
                        name = content.slice(prefix.length).trim();
                        break;
                    }
                }
                
                return {
                    id: elementId,
                    key: part,
                    type: subType,
                    name: name,
                    width: 120,
                    height: 80
                };
            }

            // Check tasks [...]
            if (part.startsWith('[') && part.endsWith(']')) {
                const content = part.slice(1, -1).trim();
                let taskType = 'task';
                let name = content;
                let marker = null;
                
                // Check for markers
                for (const [markerSuffix, markerConfig] of Object.entries(TASK_MARKERS)) {
                    if (content.endsWith(markerSuffix)) {
                        marker = markerConfig;
                        name = content.slice(0, -markerSuffix.length).trim();
                        break;
                    }
                }
                
                // Check for call activity (special case - uses single brackets)
                if (name.toLowerCase().startsWith('call:')) {
                    return {
                        id: elementId,
                        key: part,
                        type: 'callActivity',
                        name: name.slice(5).trim(),
                        marker: marker,
                        width: 100,
                        height: 80
                    };
                }
                
                // Check for task type prefix
                for (const [prefix, config] of Object.entries(TASK_TYPES)) {
                    if (prefix && name.toLowerCase().startsWith(prefix)) {
                        taskType = config.type;
                        name = name.slice(prefix.length).trim();
                        break;
                    }
                }
                
                return {
                    id: elementId,
                    key: part,
                    type: taskType,
                    name: name,
                    marker: marker,
                    width: 100,
                    height: 80
                };
            }

            // Check data objects
            if (part.startsWith('{') && part.endsWith('}')) {
                const content = part.slice(1, -1).trim();
                let dataType = 'dataObjectReference';
                let name = content;
                
                for (const [prefix, config] of Object.entries(DATA_TYPES)) {
                    const checkPrefix = prefix.slice(1); // Remove {
                    if (content.toLowerCase().startsWith(checkPrefix)) {
                        dataType = config.type;
                        name = content.slice(checkPrefix.length).trim();
                        break;
                    }
                }
                
                return {
                    id: elementId,
                    key: part,
                    type: dataType,
                    name: name,
                    width: 36,
                    height: 50
                };
            }

            // Check text annotations
            if (part.startsWith('//')) {
                return {
                    id: elementId,
                    key: part,
                    type: 'textAnnotation',
                    name: part.slice(2).trim(),
                    width: 100,
                    height: 50
                };
            }

            // Default: treat as task
            return {
                id: elementId,
                key: part,
                type: 'task',
                name: part,
                width: 100,
                height: 80
            };
        }

        // ============================================================
        // BPMN XML GENERATOR
        // ============================================================
        function generateBPMNXml(parsed) {
            const { elements, flows } = parsed;
            
            // Layout with dagre
            const g = new dagre.graphlib.Graph();
            g.setGraph({ rankdir: 'LR', nodesep: 60, ranksep: 100, marginx: 50, marginy: 50 });
            g.setDefaultEdgeLabel(() => ({}));

            elements.forEach((el, key) => {
                g.setNode(key, { width: el.width, height: el.height, element: el });
            });

            flows.forEach(flow => {
                g.setEdge(flow.sourceKey, flow.targetKey);
            });

            dagre.layout(g);

            // Get positions
            const positions = new Map();
            g.nodes().forEach(key => {
                const node = g.node(key);
                if (node) {
                    positions.set(key, {
                        x: Math.round(node.x - node.width / 2),
                        y: Math.round(node.y - node.height / 2),
                        width: node.width,
                        height: node.height
                    });
                }
            });

            // Generate XML
            let processContent = '';
            let shapeContent = '';

            elements.forEach((el, key) => {
                const pos = positions.get(key) || { x: 100, y: 100 };
                processContent += generateElementXml(el);
                shapeContent += generateShapeXml(el, pos);
            });

            let edgeContent = '';
            flows.forEach(flow => {
                processContent += generateFlowXml(flow);
                edgeContent += generateEdgeXml(flow, g, positions, elements);
            });

            return `<?xml version="1.0" encoding="UTF-8"?>
<bpmn:definitions xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL"
    xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI"
    xmlns:dc="http://www.omg.org/spec/DD/20100524/DC"
    xmlns:di="http://www.omg.org/spec/DD/20100524/DI"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    id="Definitions_1"
    targetNamespace="http://bpmn.io/schema/bpmn"
    exporter="BPMN 2.0 Editor"
    exporterVersion="1.0">
  <bpmn:process id="Process_1" isExecutable="false">
${processContent}  </bpmn:process>
  <bpmndi:BPMNDiagram id="BPMNDiagram_1">
    <bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1">
${shapeContent}${edgeContent}    </bpmndi:BPMNPlane>
  </bpmndi:BPMNDiagram>
</bpmn:definitions>`;
        }

        function generateElementXml(el) {
            const name = escapeXml(el.name);
            const trigger = el.trigger ? `<bpmn:${el.trigger}/>` : '';
            
            // Handle markers
            let markerXml = '';
            if (el.marker) {
                if (el.marker.loopCharacteristics === 'standardLoopCharacteristics') {
                    markerXml = '<bpmn:standardLoopCharacteristics/>';
                } else if (el.marker.loopCharacteristics === 'multiInstanceLoopCharacteristics') {
                    const seq = el.marker.isSequential ? ' isSequential="true"' : '';
                    markerXml = `<bpmn:multiInstanceLoopCharacteristics${seq}/>`;
                }
            }

            switch (el.type) {
                case 'startEvent':
                    return `    <bpmn:startEvent id="${el.id}" name="${name}">${trigger}</bpmn:startEvent>\n`;
                case 'endEvent':
                    return `    <bpmn:endEvent id="${el.id}" name="${name}">${trigger}</bpmn:endEvent>\n`;
                case 'intermediateCatchEvent':
                    return `    <bpmn:intermediateCatchEvent id="${el.id}" name="${name}">${trigger}</bpmn:intermediateCatchEvent>\n`;
                case 'intermediateThrowEvent':
                    return `    <bpmn:intermediateThrowEvent id="${el.id}" name="${name}">${trigger}</bpmn:intermediateThrowEvent>\n`;
                case 'task':
                    return `    <bpmn:task id="${el.id}" name="${name}">${markerXml}</bpmn:task>\n`;
                case 'userTask':
                    return `    <bpmn:userTask id="${el.id}" name="${name}">${markerXml}</bpmn:userTask>\n`;
                case 'serviceTask':
                    return `    <bpmn:serviceTask id="${el.id}" name="${name}">${markerXml}</bpmn:serviceTask>\n`;
                case 'scriptTask':
                    return `    <bpmn:scriptTask id="${el.id}" name="${name}">${markerXml}</bpmn:scriptTask>\n`;
                case 'businessRuleTask':
                    return `    <bpmn:businessRuleTask id="${el.id}" name="${name}">${markerXml}</bpmn:businessRuleTask>\n`;
                case 'sendTask':
                    return `    <bpmn:sendTask id="${el.id}" name="${name}">${markerXml}</bpmn:sendTask>\n`;
                case 'receiveTask':
                    return `    <bpmn:receiveTask id="${el.id}" name="${name}">${markerXml}</bpmn:receiveTask>\n`;
                case 'manualTask':
                    return `    <bpmn:manualTask id="${el.id}" name="${name}">${markerXml}</bpmn:manualTask>\n`;
                case 'subProcess':
                    return `    <bpmn:subProcess id="${el.id}" name="${name}"/>\n`;
                case 'callActivity':
                    return `    <bpmn:callActivity id="${el.id}" name="${name}"/>\n`;
                case 'transaction':
                    return `    <bpmn:transaction id="${el.id}" name="${name}"/>\n`;
                case 'adHocSubProcess':
                    return `    <bpmn:adHocSubProcess id="${el.id}" name="${name}"/>\n`;
                case 'exclusiveGateway':
                    return `    <bpmn:exclusiveGateway id="${el.id}" name="${name}"/>\n`;
                case 'parallelGateway':
                    return `    <bpmn:parallelGateway id="${el.id}" name="${name}"/>\n`;
                case 'inclusiveGateway':
                    return `    <bpmn:inclusiveGateway id="${el.id}" name="${name}"/>\n`;
                case 'complexGateway':
                    return `    <bpmn:complexGateway id="${el.id}" name="${name}"/>\n`;
                case 'eventBasedGateway':
                    return `    <bpmn:eventBasedGateway id="${el.id}" name="${name}"/>\n`;
                case 'dataObjectReference':
                    return `    <bpmn:dataObjectReference id="${el.id}" name="${name}"/>\n`;
                case 'dataStoreReference':
                    return `    <bpmn:dataStoreReference id="${el.id}" name="${name}"/>\n`;
                case 'textAnnotation':
                    return `    <bpmn:textAnnotation id="${el.id}"><bpmn:text>${name}</bpmn:text></bpmn:textAnnotation>\n`;
                default:
                    return `    <bpmn:task id="${el.id}" name="${name}"/>\n`;
            }
        }

        function generateShapeXml(el, pos) {
            const isGateway = el.type.includes('Gateway');
            const isEvent = el.type.includes('Event');
            const markerVisible = isGateway ? ' isMarkerVisible="true"' : '';
            
            let labelXml = '';
            if ((isGateway || isEvent) && el.name) {
                labelXml = `\n        <bpmndi:BPMNLabel>
          <dc:Bounds x="${pos.x - 10}" y="${pos.y + pos.height + 5}" width="${pos.width + 20}" height="14"/>
        </bpmndi:BPMNLabel>`;
            }
            
            return `      <bpmndi:BPMNShape id="${el.id}_di" bpmnElement="${el.id}"${markerVisible}>
        <dc:Bounds x="${pos.x}" y="${pos.y}" width="${pos.width}" height="${pos.height}"/>${labelXml}
      </bpmndi:BPMNShape>\n`;
        }

        function generateFlowXml(flow) {
            const name = flow.name ? ` name="${escapeXml(flow.name)}"` : '';
            return `    <bpmn:sequenceFlow id="${flow.id}"${name} sourceRef="${flow.sourceRef}" targetRef="${flow.targetRef}"/>\n`;
        }

        function generateEdgeXml(flow, g, positions, elements) {
            const sourceEl = elements.get(flow.sourceKey);
            const targetEl = elements.get(flow.targetKey);
            const sp = positions.get(flow.sourceKey);
            const tp = positions.get(flow.targetKey);
            
            if (!sp || !tp || !sourceEl || !targetEl) {
                return '';
            }

            // Calculate connection points based on relative positions
            let waypoints = '';
            
            // Source center
            const srcCenterX = sp.x + sp.width / 2;
            const srcCenterY = sp.y + sp.height / 2;
            
            // Target center
            const tgtCenterX = tp.x + tp.width / 2;
            const tgtCenterY = tp.y + tp.height / 2;
            
            // Determine connection sides based on relative position
            const dx = tgtCenterX - srcCenterX;
            const dy = tgtCenterY - srcCenterY;
            
            // Check if this is a "backwards" flow (target is to the left of source)
            const isBackwardsFlow = dx < -50;
            
            if (isBackwardsFlow) {
                // Route backwards flows: go down from source, left, then up to target
                const srcX = srcCenterX;
                const srcY = sp.y + sp.height; // Bottom of source
                const tgtX = tgtCenterX;
                const tgtY = tp.y + tp.height; // Bottom of target
                
                // Go below both elements
                const routeY = Math.max(srcY, tgtY) + 40;
                
                waypoints = `        <di:waypoint x="${Math.round(srcX)}" y="${Math.round(srcY)}"/>
        <di:waypoint x="${Math.round(srcX)}" y="${Math.round(routeY)}"/>
        <di:waypoint x="${Math.round(tgtX)}" y="${Math.round(routeY)}"/>
        <di:waypoint x="${Math.round(tgtX)}" y="${Math.round(tgtY)}"/>\n`;
            } else {
                // Normal left-to-right flow
                const isHorizontal = Math.abs(dx) > Math.abs(dy);
                
                let srcX, srcY, tgtX, tgtY;
                
                if (isHorizontal) {
                    if (dx > 0) {
                        // Target is to the right - connect right side to left side
                        srcX = sp.x + sp.width;
                        srcY = srcCenterY;
                        tgtX = tp.x;
                        tgtY = tgtCenterY;
                    } else {
                        // Target is slightly to the left but close - connect left to right
                        srcX = sp.x;
                        srcY = srcCenterY;
                        tgtX = tp.x + tp.width;
                        tgtY = tgtCenterY;
                    }
                    
                    // If there's significant vertical difference, add intermediate waypoints
                    if (Math.abs(dy) > 20) {
                        const midX = (srcX + tgtX) / 2;
                        waypoints = `        <di:waypoint x="${Math.round(srcX)}" y="${Math.round(srcY)}"/>
        <di:waypoint x="${Math.round(midX)}" y="${Math.round(srcY)}"/>
        <di:waypoint x="${Math.round(midX)}" y="${Math.round(tgtY)}"/>
        <di:waypoint x="${Math.round(tgtX)}" y="${Math.round(tgtY)}"/>\n`;
                    } else {
                        waypoints = `        <di:waypoint x="${Math.round(srcX)}" y="${Math.round(srcY)}"/>
        <di:waypoint x="${Math.round(tgtX)}" y="${Math.round(tgtY)}"/>\n`;
                    }
                } else {
                    if (dy > 0) {
                        // Target is below - connect bottom to top
                        srcX = srcCenterX;
                        srcY = sp.y + sp.height;
                        tgtX = tgtCenterX;
                        tgtY = tp.y;
                    } else {
                        // Target is above - connect top to bottom
                        srcX = srcCenterX;
                        srcY = sp.y;
                        tgtX = tgtCenterX;
                        tgtY = tp.y + tp.height;
                    }
                    
                    // If there's significant horizontal difference, add intermediate waypoints
                    if (Math.abs(dx) > 20) {
                        const midY = (srcY + tgtY) / 2;
                        waypoints = `        <di:waypoint x="${Math.round(srcX)}" y="${Math.round(srcY)}"/>
        <di:waypoint x="${Math.round(srcX)}" y="${Math.round(midY)}"/>
        <di:waypoint x="${Math.round(tgtX)}" y="${Math.round(midY)}"/>
        <di:waypoint x="${Math.round(tgtX)}" y="${Math.round(tgtY)}"/>\n`;
                    } else {
                        waypoints = `        <di:waypoint x="${Math.round(srcX)}" y="${Math.round(srcY)}"/>
        <di:waypoint x="${Math.round(tgtX)}" y="${Math.round(tgtY)}"/>\n`;
                    }
                }
            }

            // Label positioning
            let labelXml = '';
            if (flow.name) {
                const labelX = Math.min(sp.x, tp.x) + Math.abs(dx) / 2;
                const labelY = Math.min(sp.y, tp.y) - 15;
                labelXml = `        <bpmndi:BPMNLabel>
          <dc:Bounds x="${Math.round(labelX)}" y="${Math.round(labelY)}" width="50" height="14"/>
        </bpmndi:BPMNLabel>\n`;
            }

            return `      <bpmndi:BPMNEdge id="${flow.id}_di" bpmnElement="${flow.id}">
${waypoints}${labelXml}      </bpmndi:BPMNEdge>\n`;
        }

        // ============================================================
        // RENDER
        // ============================================================
        async function render() {
            const code = document.getElementById('codeEditor').value.trim();
            if (!code) {
                updateStatus('Empty', true);
                return;
            }

            try {
                const parsed = parseDSL(code);
                const xml = generateBPMNXml(parsed);
                lastBpmnXml = xml;

                await bpmnViewer.importXML(xml);
                centerDiagram();

                updateStatus('Ready', false);
                document.getElementById('elementCount').textContent = `${parsed.elements.size} elements`;
            } catch (err) {
                console.error('Render error:', err);
                updateStatus('Error: ' + err.message, true);
                lastBpmnXml = null;
            }
        }

        function centerDiagram() {
            if (!bpmnViewer) return;
            
            try {
                const canvas = bpmnViewer.get('canvas');
                canvas.zoom('fit-viewport');
                updateZoomDisplay();
            } catch (err) {
                console.error('Center error:', err);
                zoomLevel = 1;
                document.getElementById('zoomLevel').textContent = '100%';
            }
        }

        function updateStatus(text, isError) {
            document.getElementById('statusText').textContent = text;
            document.getElementById('statusDot').classList.toggle('error', isError);
        }

        // ============================================================
        // ZOOM
        // ============================================================
        function zoomIn() {
            if (!bpmnViewer) return;
            
            try {
                const canvas = bpmnViewer.get('canvas');
                zoomLevel = Math.min(zoomLevel + 0.2, 4);
                canvas.zoom(zoomLevel);
                document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
            } catch (err) {
                console.error('Zoom error:', err);
            }
        }

        function zoomOut() {
            if (!bpmnViewer) return;
            
            try {
                const canvas = bpmnViewer.get('canvas');
                zoomLevel = Math.max(zoomLevel - 0.2, 0.2);
                canvas.zoom(zoomLevel);
                document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
            } catch (err) {
                console.error('Zoom error:', err);
            }
        }
        
        function updateZoomDisplay() {
            if (!bpmnViewer) return;
            try {
                const canvas = bpmnViewer.get('canvas');
                zoomLevel = canvas.zoom();
                document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
            } catch (err) {}
        }

        function fitView() {
            centerDiagram();
        }

        // ============================================================
        // PAN / NAVIGATION
        // ============================================================
        function panCanvas(deltaX, deltaY) {
            if (!bpmnViewer) return;
            
            try {
                const canvas = bpmnViewer.get('canvas');
                const viewbox = canvas.viewbox();
                
                canvas.viewbox({
                    x: viewbox.x - deltaX,
                    y: viewbox.y - deltaY,
                    width: viewbox.width,
                    height: viewbox.height
                });
            } catch (err) {
                console.error('Pan error:', err);
            }
        }

        function resetView() {
            centerDiagram();
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            // Only handle if preview panel is focused or no input is focused
            const activeEl = document.activeElement;
            if (activeEl && (activeEl.tagName === 'TEXTAREA' || activeEl.tagName === 'INPUT')) {
                return;
            }
            
            const panAmount = e.shiftKey ? 200 : 80;
            
            switch (e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    panCanvas(0, -panAmount);
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    panCanvas(0, panAmount);
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    panCanvas(-panAmount, 0);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    panCanvas(panAmount, 0);
                    break;
                case 'Home':
                    e.preventDefault();
                    resetView();
                    break;
                case '+':
                case '=':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        zoomIn();
                    }
                    break;
                case '-':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        zoomOut();
                    }
                    break;
            }
        });

        // ============================================================
        // EXPORT
        // ============================================================
        function exportBPMN() {
            closeDropdowns();
            if (!lastBpmnXml) {
                showToast('No diagram to export');
                return;
            }
            downloadFile(lastBpmnXml, `process-${Date.now()}.bpmn`, 'application/xml');
            showToast('BPMN XML exported');
        }

        async function exportSVG() {
            closeDropdowns();
            if (!bpmnViewer) {
                showToast('No diagram to export');
                return;
            }
            try {
                const { svg } = await bpmnViewer.saveSVG();
                downloadFile(svg, `diagram-${Date.now()}.svg`, 'image/svg+xml');
                showToast('SVG exported');
            } catch (err) {
                showToast('Export failed: ' + err.message);
            }
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ============================================================
        // IMPORT
        // ============================================================
        function importFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                document.getElementById('codeEditor').value = e.target.result;
                render();
                showToast('File imported');
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // ============================================================
        // EXAMPLES
        // ============================================================
        function loadExample(name) {
            closeDropdowns();
            if (EXAMPLES[name]) {
                document.getElementById('codeEditor').value = EXAMPLES[name];
                render();
                showToast('Loaded: ' + name);
            }
        }

        // ============================================================
        // UI HELPERS
        // ============================================================
        function toggleDropdown(id) {
            const menu = document.getElementById(id);
            const wasOpen = menu.classList.contains('open');
            closeDropdowns();
            if (!wasOpen) menu.classList.add('open');
        }

        function closeDropdowns() {
            document.querySelectorAll('.dropdown-menu').forEach(m => m.classList.remove('open'));
        }

        function copyCode() {
            navigator.clipboard.writeText(document.getElementById('codeEditor').value);
            showToast('Copied to clipboard');
        }

        function clearEditor() {
            document.getElementById('codeEditor').value = '';
            if (bpmnViewer) bpmnViewer.clear();
            lastBpmnXml = null;
            updateStatus('Cleared', false);
            document.getElementById('elementCount').textContent = '0 elements';
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        // ============================================================
        // RESIZER
        // ============================================================
        function initResizer() {
            const handle = document.getElementById('resizeHandle');
            const panel = document.getElementById('editorPanel');
            let startX, startWidth;

            handle.addEventListener('mousedown', (e) => {
                startX = e.clientX;
                startWidth = panel.offsetWidth;
                document.addEventListener('mousemove', resize);
                document.addEventListener('mouseup', stopResize);
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });

            function resize(e) {
                const newWidth = startWidth + (e.clientX - startX);
                if (newWidth > 350 && newWidth < window.innerWidth - 400) {
                    panel.style.width = newWidth + 'px';
                }
            }

            function stopResize() {
                document.removeEventListener('mousemove', resize);
                document.removeEventListener('mouseup', stopResize);
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        }

        // ============================================================
        // UTILITIES
        // ============================================================
        function escapeXml(str) {
            if (!str) return '';
            return str.replace(/&/g, '&amp;')
                      .replace(/</g, '&lt;')
                      .replace(/>/g, '&gt;')
                      .replace(/"/g, '&quot;')
                      .replace(/'/g, '&apos;');
        }

        function escapeHtml(str) {
            return str.replace(/&/g, '&amp;')
                      .replace(/</g, '&lt;')
                      .replace(/>/g, '&gt;')
                      .replace(/"/g, '&quot;');
        }
    </script>
</body>
</html>
